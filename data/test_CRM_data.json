[{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"I'm looking to promote top picks for customer ID '12345' residing in Kingston. Could you provide me with 5 recommendations based on their transaction history?"},{"role":"assistant","content":"def promote_top_picks(df, customer_df, product_df, customer_id='12345', city='Kingston', n_recommendations=5):\\n    df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    df_city = df[(df['customer_city'] == city) & (df['user_id'] == customer_id)]\\n    if df_city.empty:\\n        print('No transactions found for the given customer ID and city.')\\n        return []\\n    le_user = LabelEncoder()\\n    le_item = LabelEncoder()\\n    df_city['user_code'] = le_user.fit_transform(df_city['user_id'])\\n    df_city['item_code'] = le_item.fit_transform(df_city['item_id'])\\n    user_item_matrix = pd.pivot_table(df_city, values='score', index='user_code', columns='item_code', fill_value=0)\\n    item_sim_matrix = cosine_similarity(user_item_matrix.T)\\n    user_transactions = df_city['item_code'].unique()\\n    recommendation_scores = {}\\n    for item_code in range(user_item_matrix.shape[1]):\\n        if item_code not in user_transactions:\\n            sim_scores = item_sim_matrix[item_code]\\n            reco_score = sum(sim_scores[user_transactions]) \/ len(sim_scores[user_transactions])\\n            recommendation_scores[item_code] = reco_score\\n    sorted_recommendations = sorted(recommendation_scores.items(), key=lambda x: x[1], reverse=True)[:n_recommendations]\\n    recommended_items = [le_item.inverse_transform(item_code) for item_code, _ in sorted_recommendations]\\n    return recommended_items\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Can you provide a breakdown of transactions by customer city and quarter per day of the week per product category?"},{"role":"assistant","content":"def transactions_breakdown(df, customer_df, product_df):\\n    merged_df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    merged_df['quarter'] = merged_df['timestamp'].dt.quarter\\n    merged_df['day_of_week'] = merged_df['timestamp'].dt.day_name()\\n    merged_df['year'] = merged_df['timestamp'].dt.year\\n    grouped = merged_df.groupby(['customer_city', 'quarter', 'day_of_week', 'product_category'])\\n    transactions_count = grouped.size().reset_index(name='transaction_count')\\n    return transactions_count\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Can you analyze the average score and total number of orders per month for each product category for our customers within a specified time interval?"},{"role":"assistant","content":"def analyze_temporal_trends(df, customer_df, product_df, time_interval='M'):\\n    df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    if not pd.api.types.is_datetime64_any_dtype(df['timestamp']):\\n        df['timestamp'] = pd.to_datetime(df['timestamp'])\\n    df['year_month'] = df['timestamp'].dt.to_period(time_interval)\\n    aggregated_data = df.groupby(['year_month', 'product_category']).agg({\\n        'score': 'mean',\\n        'order_id': 'count'\\n    }).reset_index()\\n    return aggregated_data\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Could you please provide me with the average score of products purchased by customer 'customer_123' across different product categories?"},{"role":"assistant","content":"def personalize_search_results(df, customer_df, product_df, customer_id='customer_123'):\\n    merged_df = pd.merge(df, customer_df, on='user_id')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id')\\n    customer_transactions = merged_df[merged_df['user_id'] == customer_id]\\n    category_scores = customer_transactions.groupby('product_category')['score'].mean()\\n    sorted_categories = category_scores.sort_values(ascending=False)\\n    return sorted_categories\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What is the average transaction value for transactions made by customers from different cities per quarter?"},{"role":"assistant","content":"def average_transaction_value_per_city_per_quarter(df, customer_df, product_df):\\n    merged_df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    merged_df['quarter'] = merged_df['timestamp'].dt.to_period('Q')\\n    merged_df['transaction_value'] = merged_df['score']\\n    avg_transaction_per_city_per_quarter = merged_df.groupby(['customer_city', 'quarter'])['transaction_value'].mean()\\n    return avg_transaction_per_city_per_quarter\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\n"},{"role":"user","content":"Customer Interaction History and Similarity"},{"role":"assistant","content":"def customer_interaction_similarity(df):\\n    interactions_per_customer = df.groupby('user_id')['item_id'].apply(' '.join).reset_index()\\n    vectorizer = TfidfVectorizer()\\n    tfidf_matrix = vectorizer.fit_transform(interactions_per_customer['item_id'])\\n    similarity_matrix = cosine_similarity(tfidf_matrix, tfidf_matrix)\\n    return similarity_matrix\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What is the average transaction value for transactions made by new customers versus repeat customers?"},{"role":"assistant","content":"def average_transaction_value(df, customer_df, product_df):\\n    merged_df = pd.merge(df, customer_df, on='user_id', how='left')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id', how='left')\\n    new_customers_avg = merged_df[merged_df['customer_city'].isnull()]['score'].mean()\\n    repeat_customers_avg = merged_df[merged_df['customer_city'].notnull()]['score'].mean()\\n    return new_customers_avg, repeat_customers_avg\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\n"},{"role":"user","content":"What is the average transaction score for transactions made during peak hours versus off-peak hours?"},{"role":"assistant","content":"def average_transaction_score(df, peak_start_hour=8, peak_end_hour=18):\\n    df['timestamp'] = pd.to_datetime(df['timestamp'])\\n    peak_mask = (df['timestamp'].dt.hour >= peak_start_hour) & (df['timestamp'].dt.hour < peak_end_hour)\\n    off_peak_mask = ~peak_mask\\n    peak_avg_score = df.loc[peak_mask, 'score'].mean()\\n    off_peak_avg_score = df.loc[off_peak_mask, 'score'].mean()\\n    return peak_avg_score, off_peak_avg_score\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\n"},{"role":"user","content":"Can you identify any patterns in transaction volume by customer city and day of the week?"},{"role":"assistant","content":"def transaction_volume_by_city_and_day(df, customer_df):\\n    merged_df = pd.merge(df, customer_df, on='user_id', how='left')\\n    merged_df['timestamp'] = pd.to_datetime(merged_df['timestamp'])\\n    merged_df['day_of_week'] = merged_df['timestamp'].dt.day_name()\\n    result = merged_df.groupby(['customer_city', 'day_of_week']).size().reset_index(name='transaction_count')\\n    return result\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Can you identify any patterns in transaction volume by product category and month?"},{"role":"assistant","content":"def transaction_volume_patterns(df, product_df):\\n    df_merged = pd.merge(df, product_df, on='item_id', how='left')\\n    df_merged['month'] = df_merged['timestamp'].dt.month\\n    volume_patterns = df_merged.groupby(['product_category', 'month']).size().reset_index(name='transaction_count')\\n    return volume_patterns\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"How many transactions have occurred for each product category per customer city and quarter?"},{"role":"assistant","content":"def transactions_per_category_per_city_per_quarter(df, customer_df, product_df):\\n    merged_df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    merged_df['timestamp'] = pd.to_datetime(merged_df['timestamp'])\\n    merged_df['quarter'] = merged_df['timestamp'].dt.to_period('Q')\\n    result = merged_df.groupby(['product_category', 'customer_city', 'quarter']).size().reset_index(name='transaction_count')\\n    return result\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Could you please provide me with the top 5 recommended items for customer 'sdihf_23' based on their previous purchases?"},{"role":"assistant","content":"def next_best_offer_recommendations(df, customer_df, product_df, target_user_id='sdihf_23', top_n=5):\\n    df = df.merge(customer_df, on='user_id', how='left')\\n    df = df.merge(product_df, on='item_id', how='left')\\n    user_encoder = LabelEncoder()\\n    item_encoder = LabelEncoder()\\n    df['encoded_user_id'] = user_encoder.fit_transform(df['user_id'])\\n    df['encoded_item_id'] = item_encoder.fit_transform(df['item_id'])\\n    user_item_matrix = csr_matrix((df['score'], (df['encoded_user_id'], df['encoded_item_id'])))\\n    item_similarity = cosine_similarity(user_item_matrix.T)\\n    target_user_index = df[df['user_id'] == target_user_id]['encoded_user_id']\\n    if target_user_index.empty:\\n        print('No transactions found for the specified user.')\\n        return pd.DataFrame(columns=['item_id', 'score'])\\n    target_user_index = target_user_index.iloc[0]\\n    items_bought_by_target_user = df[df['encoded_user_id'] == target_user_index]['encoded_item_id'].unique()\\n    scores = item_similarity[:, items_bought_by_target_user].sum(axis=1)\\n    recommended_items = pd.DataFrame({'encoded_item_id': range(len(scores)), 'score': scores})\\n    recommended_items = recommended_items[~recommended_items['encoded_item_id'].isin(items_bought_by_target_user)]\\n    recommended_items = recommended_items.sort_values(by='score', ascending=False).head(top_n)\\n    recommended_items['item_id'] = item_encoder.inverse_transform(recommended_items['encoded_item_id'])\\n    return recommended_items[['item_id', 'score']]\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What is the most common product category purchased by customers?"},{"role":"assistant","content":"def most_common_product_category(df, customer_df, product_df):\\n    merged_df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    category_counts = merged_df['product_category'].value_counts()\\n    most_common_category = category_counts.idxmax()\\n    return most_common_category\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\n"},{"role":"user","content":"What is the average time between repeat transactions for each customer?"},{"role":"assistant","content":"def average_time_between_transactions_per_customer(df, customer_df, user_id_col='user_id', timestamp_col='timestamp'):\\n    merged_df = df.merge(customer_df, on=user_id_col, how='left')\\n    merged_df[timestamp_col] = pd.to_datetime(merged_df[timestamp_col])\\n    sorted_df = merged_df.sort_values(by=[user_id_col, timestamp_col])\\n    sorted_df['time_diff'] = sorted_df.groupby(user_id_col)[timestamp_col].diff()\\n    avg_time_per_customer = sorted_df.groupby(user_id_col)['time_diff'].mean()\\n    return avg_time_per_customer\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Can you identify any patterns in transaction volume by customer city and day per quarter per product category?"},{"role":"assistant","content":"def transaction_volume_patterns(df, customer_df, product_df):\\n    merged_df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    merged_df['timestamp'] = pd.to_datetime(merged_df['timestamp'])\\n    merged_df['quarter'] = merged_df['timestamp'].dt.quarter\\n    merged_df['day'] = merged_df['timestamp'].dt.day\\n    grouped_df = merged_df.groupby(['customer_city', 'quarter', 'day', 'product_category']).size().reset_index(name='transaction_count')\\n    return grouped_df\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\n"},{"role":"user","content":"How frequently are the \"you may also like\" recommendations updated or refreshed?"},{"role":"assistant","content":"def calculate_refresh_frequency(df):\\n    df_sorted = df.sort_values(by='timestamp')\\n    time_diff = (df_sorted['timestamp'] - df_sorted['timestamp'].shift(1)).dropna()\\n    avg_refresh_time = time_diff.mean()\\n    return avg_refresh_time\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"How can we predict the likelihood of a customer making a purchase based on their transaction history?"},{"role":"assistant","content":"def predict_purchase_likelihood(df, customer_df, product_df, threshold=0.75):\\n    merged_df = pd.merge(df, customer_df, on='user_id')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id')\\n    features = pd.get_dummies(merged_df[['customer_city', 'product_category']])\\n    target = merged_df['score']\\n    X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.2, random_state=42)\\n    model = LogisticRegression()\\n    model.fit(X_train, (y_train > threshold).astype(int))  \\n    y_pred_proba = model.predict_proba(X_test)[:, 1]\\n    return y_pred_proba\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"How do the sales of complementary products vary across different regions or customer demographics?"},{"role":"assistant","content":"def analyze_complementary_product_sales(df, customer_df, product_df, region=None):\\n    \"\"\"\\n    Analyzes the sales of complementary products across different regions.\\n    Args:\\n    df (DataFrame): Pandas DataFrame containing transaction data.\\n    customer_df (DataFrame): Pandas DataFrame containing customer data.\\n    product_df (DataFrame): Pandas DataFrame containing product data.\\n    region (str, optional): Name of the region to analyze. Default is None (all regions).\\n    Returns:\\n    DataFrame: DataFrame containing the sales of complementary products.\\n    \"\"\"\\n    merged_df = pd.merge(df, customer_df, on='user_id')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id')\\n    if region:\\n        merged_df = merged_df[merged_df['customer_city'] == region]\\n    sales_by_category = merged_df.groupby('product_category').size().reset_index(name='sales_count')\\n    return sales_by_category\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Can you provide insights into the ROI of implementing personalized search features on our platform?"},{"role":"assistant","content":"def calculate_roi(df, customer_df, product_df):\\n    merged_df = pd.merge(df, customer_df, on='user_id')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id')\\n    total_revenue_before = df['score'].sum()\\n    total_revenue_after = merged_df['score'].sum()\\n    roi = (total_revenue_after - total_revenue_before) \/ total_revenue_before * 100\\n    return roi\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Could you please provide the average score of product categories purchased by customers located in New York?"},{"role":"assistant","content":"def tailor_location_based_offers(df, customer_df, product_df, target_city='New York'):\\n    merged_df = pd.merge(df, customer_df, on='user_id', how='inner')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id', how='inner')\\n    city_transactions = merged_df[merged_df['customer_city'] == target_city]\\n    category_scores = city_transactions.groupby('product_category')['score'].mean().reset_index()\\n    return category_scores\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"CRM Content Strategy Recommendations"},{"role":"assistant","content":"def crm_content_strategy(df, customer_df, product_df):\\n    merged_df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    result_df = merged_df.groupby(['customer_city', 'product_category']).agg(\\n        avg_score=('score', 'mean'),\\n        transaction_count=('order_id', 'count')\\n    ).reset_index()\\n    return result_df\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"How do the purchase likelihood predictions vary across different customer segments or demographics?"},{"role":"assistant","content":"def purchase_likelihood_predictions(df, customer_df, product_df):\\n    merged_df = pd.merge(df, customer_df, on='user_id', how='left')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id', how='left')\\n    groupby_city_category = merged_df.groupby(['customer_city', 'product_category'])['score'].mean().reset_index()\\n    return groupby_city_category\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Can you update recommendations for user '12345' based on their feedback on certain items?"},{"role":"assistant","content":"def update_recommendations(df, customer_df, product_df, user_id='12345', feedback=None):\\n    '''\\n    Update recommendations based on customer feedback.\\n    Args:\\n    - df (DataFrame): Transaction data.\\n    - customer_df (DataFrame): Customer data.\\n    - product_df (DataFrame): Product data.\\n    - user_id (str): ID of the customer providing feedback.\\n    - feedback (dict): Dictionary containing feedback in the format {'item_id': score}.\\n    Returns:\\n    - updated_recommendations (DataFrame): Updated recommendations for the customer.\\n    '''\\n    if not all(isinstance(data, pd.DataFrame) for data in [df, customer_df, product_df]):\\n        raise ValueError('Input data must be pandas DataFrames.')\\n    required_columns = {'user_id', 'item_id', 'score'}\\n    if not all(column in df.columns for column in required_columns):\\n        raise ValueError('Transaction data is missing required columns.')\\n    if 'user_id' not in customer_df.columns:\\n        raise ValueError('''Customer data is missing 'user_id' column.''')\\n    if 'item_id' not in product_df.columns:\\n        raise ValueError('''Product data is missing 'item_id' column.''')\\n    merged_df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    user_transactions = merged_df[merged_df['user_id'] == user_id]\\n    category_scores = user_transactions.groupby('product_category')['score'].mean().reset_index()\\n    category_scores.rename(columns={'score': 'category_avg_score'}, inplace=True)\\n    product_df = product_df.merge(category_scores, on='product_category', how='left')\\n    if feedback is not None:\\n        feedback_df = pd.DataFrame.from_dict(feedback, orient='index', columns=['user_feedback']).reset_index()\\n        feedback_df.rename(columns={'index': 'item_id'}, inplace=True)\\n        product_df = product_df.merge(feedback_df, on='item_id', how='left')\\n    if 'user_feedback' not in product_df.columns:\\n        product_df['user_feedback'] = 0.0\\n    product_df['final_score'] = product_df['category_avg_score'].fillna(0) + product_df['user_feedback'].fillna(0)\\n    updated_recommendations = product_df.sort_values(by='final_score', ascending=False)\\n    return updated_recommendations\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\n"},{"role":"user","content":"Can you identify any patterns in transaction scores by day of the week?"},{"role":"assistant","content":"def transaction_score_by_day_of_week(df):\\n    df['timestamp'] = pd.to_datetime(df['timestamp'])\\n    df['day_of_week'] = df['timestamp'].dt.day_name()\\n    avg_score_by_day = df.groupby('day_of_week')['score'].mean().reset_index()\\n    return avg_score_by_day\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"How do you determine which products are considered related to each other?"},{"role":"assistant","content":"def find_related_products(df, product_df):\\n    df_merged = pd.merge(df, product_df, on='item_id', how='left')\\n    encoder = LabelEncoder()\\n    df_merged['user_id'] = encoder.fit_transform(df_merged['user_id'])\\n    df_merged['item_id'] = encoder.fit_transform(df_merged['item_id'])\\n    df_merged['product_category'] = encoder.fit_transform(df_merged['product_category'])\\n    user_item_matrix = pd.pivot_table(df_merged, values='score', index='user_id', columns='item_id', fill_value=0)\\n    item_similarity = cosine_similarity(user_item_matrix.T)\\n    item_similarity_df = pd.DataFrame(item_similarity, index=user_item_matrix.columns, columns=user_item_matrix.columns)\\n    related_products = {}\\n    for item_id in item_similarity_df.columns:\\n        related_products[item_id] = item_similarity_df[item_id].sort_values(ascending=False).index[1:6].tolist()\\n    return related_products\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\n"},{"role":"user","content":"What is the predicted likelihood (score) of Rohit purchasing Biscuit in the next month based on recent transaction data?"},{"role":"assistant","content":"def predict_next_purchase_recent_data(df, user_id='Rohit', item_id='Biscuit'):\\n    recent_data = df[df['timestamp'] >= df['timestamp'].max() - pd.DateOffset(months=1)]\\n    user_encoder = LabelEncoder()\\n    item_encoder = LabelEncoder()\\n    recent_data['encoded_user_id'] = user_encoder.fit_transform(recent_data['user_id'])\\n    recent_data['encoded_item_id'] = item_encoder.fit_transform(recent_data['item_id'])\\n    user_item_matrix = recent_data.pivot_table(index='encoded_user_id', columns='encoded_item_id', values='score', fill_value=0)\\n    n_components = min(user_item_matrix.shape) - 1\\n    svd_model = TruncatedSVD(n_components=n_components, random_state=42)\\n    user_item_matrix_svd = svd_model.fit_transform(user_item_matrix)\\n    if user_id not in recent_data['user_id'].unique():\\n        print(f'''User ID '{user_id}' not found in the recent transaction data.''')\\n        return\\n    if item_id not in recent_data['item_id'].unique():\\n        print(f'''Item ID '{item_id}' not found in the recent transaction data.''')\\n        return\\n    user_index = user_encoder.transform([user_id])[0]\\n    item_index = item_encoder.transform([item_id])[0]\\n    predicted_score = user_item_matrix_svd[user_index, :].dot(user_item_matrix_svd.T[item_index, :])\\n    return predicted_score\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"How do the churn predictions align with our overall customer retention goals and objectives?"},{"role":"assistant","content":"def align_churn_predictions_with_retention_goals(df, customer_df, product_df):\\n    df = pd.merge(df, customer_df, on='user_id', how='left')\\n    df = pd.merge(df, product_df, on='item_id', how='left')\\n    customer_purchase_counts = df.groupby('user_id').size().reset_index(name='total_purchases')\\n    df = pd.merge(df, customer_purchase_counts, on='user_id', how='left')\\n    avg_purchase_score = df.groupby('user_id')['score'].mean().reset_index(name='avg_purchase_score')\\n    df = pd.merge(df, avg_purchase_score, on='user_id', how='left')\\n    churn_threshold = pd.Timestamp.now() - pd.DateOffset(months=3)\\n    df['timestamp'] = pd.to_datetime(df['timestamp'])  \\n    churn_labels = df.groupby('user_id')['timestamp'].max() < churn_threshold\\n    churn_labels = churn_labels.reset_index(name='churned')\\n    customer_df = pd.merge(customer_df, churn_labels, on='user_id', how='left')\\n    df = pd.merge(df, churn_labels, on='user_id', how='left')\\n    X = df[['total_purchases', 'avg_purchase_score']]\\n    y = churn_labels['churned']\\n    overall_churn_rate = churn_labels['churned'].mean()\\n    churn_rate_by_category = df.groupby('product_category')['churned'].mean()\\n    retention_rate_by_city = customer_df.groupby('customer_city')['churned'].mean()\\n    if overall_churn_rate > 0.2:\\n        print(\"The overall churn rate exceeds the acceptable threshold. Further actions may be needed.\")\\n    else:\\n        print(\"The overall churn rate is within acceptable limits.\")\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What are the unique customer IDs who have purchased the top 5 highest-ranked products across all categories, based on the given transactions and products?"},{"role":"assistant","content":"def customers_with_highest_ranked_products(df, product_df, top_n=5):\\n    merged_df = df.merge(product_df, on='item_id')\\n    category_product_scores = merged_df.groupby(['product_category', 'item_id'])['score'].sum()\\n    ranked_products_within_categories = category_product_scores.groupby('product_category', group_keys=False).nlargest(len(category_product_scores))\\n    top_n_products = ranked_products_within_categories.groupby('product_category').head(top_n).reset_index()\\n    merged_df = merged_df.merge(top_n_products, on=['product_category', 'item_id'])\\n    unique_customers = merged_df['user_id'].unique()\\n    return unique_customers\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\n"},{"role":"user","content":"Can you identify any outliers in transaction timestamps?"},{"role":"assistant","content":"def identify_outliers(df):\\n    mean_timestamp = df['timestamp'].mean()\\n    std_timestamp = df['timestamp'].std()\\n    threshold = 3 * std_timestamp\\n    outliers = df[(df['timestamp'] < mean_timestamp - threshold) | (df['timestamp'] > mean_timestamp + threshold)]\\n    return outliers\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What is the accuracy and reliability of our purchase likelihood predictions for customers in a specific city, considering a particular product category, with a threshold of 0.5?"},{"role":"assistant","content":"def evaluate_purchase_predictions(df, customer_df, product_df, threshold=0.5):\\n    \"\"\"\\n    Evaluate the accuracy and reliability of purchase likelihood predictions.\\n    Args:\\n    - df (DataFrame): Pandas DataFrame containing transaction data with columns 'order_id', 'user_id', 'item_id', 'timestamp', 'score'.\\n    - customer_df (DataFrame): Pandas DataFrame containing customer data with columns 'user_id', 'customer_city'.\\n    - product_df (DataFrame): Pandas DataFrame containing product data with columns 'item_id', 'product_category'.\\n    - threshold (float): Threshold to determine if a purchase is predicted or not. Default is 0.5.\\n    Returns:\\n    - dict: Evaluation metrics including accuracy, classification report.\\n    \"\"\"\\n    df = df.merge(customer_df, on='user_id').merge(product_df, on='item_id')\\n    df['predicted_purchase'] = (df['score'] >= threshold).astype(int)\\n    actual_purchases = df.groupby(['user_id', 'item_id'])['score'].max().reset_index()\\n    actual_purchases['actual_purchase'] = 1\\n    merged_df = df.merge(actual_purchases, on=['user_id', 'item_id'], how='left')\\n    merged_df['actual_purchase'] = merged_df['actual_purchase'].fillna(0).astype(int)\\n    accuracy = accuracy_score(merged_df['actual_purchase'], merged_df['predicted_purchase'])\\n    classification_rep = classification_report(merged_df['actual_purchase'], merged_df['predicted_purchase'], labels=[0, 1], target_names=['No Purchase', 'Purchase'], output_dict=True, zero_division=1)\\n    evaluation_results = {\\n        'accuracy': accuracy,\\n        'classification_report': classification_rep\\n    }\\n    return evaluation_results\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\r\n\r\nExplanation - In a retail domain, understanding top-rated products among customers is crucial for targeted marketing and inventory management. With the provided data model, we have transaction data (df) containing information such as order_id, user_id, item_id, timestamp, and score, where score represents the rating of the transaction. Additionally, we have customer data (customer_df) with user_id and customer_city, as well as product data (product_df) with item_id and product_category. This data model allows us to analyze customer transactions, their ratings, and their associated cities and product categories.\n"},{"role":"user","content":"CRM user queries on top-rated products in a retail domain"},{"role":"assistant","content":"def top_rated_products(df, customer_df, product_df):\\n    '''\\n    Returns the highest-rated product for each customer.\\n    Args:\\n        df (pd.DataFrame): Pandas DataFrame containing transaction data.\\n            Columns: 'order_id', 'user_id', 'item_id', 'timestamp', 'score'.\\n        customer_df (pd.DataFrame): Pandas DataFrame containing customer data.\\n            Columns: 'user_id', 'customer_city'.\\n        product_df (pd.DataFrame): Pandas DataFrame containing product data.\\n            Columns: 'item_id', 'product_category'.\\n    Returns:\\n        pd.DataFrame: DataFrame with user_id as index and corresponding top-rated product, city, and product category as columns.\\n    '''\\n    merged_df = pd.merge(df, customer_df, on='user_id')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id')\\n    idx = merged_df.groupby('user_id')['score'].idxmax()\\n    top_rated = merged_df.loc[idx, ['user_id', 'item_id', 'customer_city', 'product_category']].reset_index(drop=True)\\n    return top_rated\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\n"},{"role":"user","content":"What is the average transaction score for transactions made by customers from different cities?"},{"role":"assistant","content":"def average_transaction_score_by_city(df, customer_df):\\n    merged_df = pd.merge(df, customer_df, on='user_id', how='inner')\\n    city_avg_scores = merged_df.groupby('customer_city')['score'].mean()\\n    return city_avg_scores\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\n"},{"role":"user","content":"What is the average transaction score per day?"},{"role":"assistant","content":"def average_transaction_score_per_day(df):\\n    if not isinstance(df['timestamp'], pd.Timestamp):\\n        df['timestamp'] = pd.to_datetime(df['timestamp'])\\n    df['date'] = df['timestamp'].dt.date\\n    avg_score_per_day = df.groupby('date')['score'].mean()\\n    return avg_score_per_day\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What is the average transaction value for transactions made by customers from different cities per month?"},{"role":"assistant","content":"def average_transaction_value_per_city_per_month(df, customer_df, product_df):\\n    merged_df = pd.merge(df, customer_df, on='user_id')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id')\\n    merged_df['month'] = merged_df['timestamp'].dt.month\\n    merged_df['transaction_value'] = merged_df['score']\\n    result = merged_df.groupby(['customer_city', 'month'])['transaction_value'].mean().reset_index()\\n    return result\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Can you provide the average score and count of transactions for each product category for customer 'sge8954'?"},{"role":"assistant","content":"def purchase_likelihood_factors(df, customer_df, product_df, customer_id='sge8954'):\\n    \"\"\"\\n    Calculate factors influencing the purchase likelihood of individual customers.\\n    Args:\\n    df (DataFrame): Pandas DataFrame containing transaction data.\\n    customer_df (DataFrame): Pandas DataFrame containing customer data.\\n    product_df (DataFrame): Pandas DataFrame containing product data.\\n    customer_id (str): Identifier of the customer for whom factors are to be calculated.\\n    Returns:\\n    DataFrame: Pandas DataFrame containing factors influencing the purchase likelihood of the specified customer.\\n    \"\"\"\\n    merged_df = pd.merge(df, customer_df, on='user_id', how='left')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id', how='left')\\n    customer_transactions = merged_df[merged_df['user_id'] == customer_id]\\n    purchase_factors = customer_transactions.groupby(['product_category']).agg({\\n        'score': ['mean', 'count']  \\n    }).reset_index()\\n    purchase_factors.columns = ['product_category', 'avg_score', 'transaction_count']\\n    return purchase_factors\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"I'd like to know the top emerging trends in product categories based on recent transactions within the last 30 days. Can you provide me with the top 3 product categories with the highest purchase counts?"},{"role":"assistant","content":"def emerging_trends(df, product_df, time_window='30D', top_n=3):\\n    df = df.merge(product_df, on='item_id')\\n    df['timestamp'] = pd.to_datetime(df['timestamp'])\\n    start_date = df['timestamp'].max() - pd.to_timedelta(time_window)\\n    recent_transactions = df[df['timestamp'] >= start_date]\\n    trend_categories = recent_transactions['product_category'].value_counts().head(top_n).reset_index()\\n    trend_categories.columns = ['product_category', 'purchase_count']\\n    return trend_categories\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What are the top 3 complementary products recommended for the customer who placed order ID '12345'?"},{"role":"assistant","content":"def recommend_complementary_products(df, customer_df, product_df, order_id='12345', top_n=3):\\n    order_transactions = df[df['order_id'] == order_id]\\n    if order_transactions.empty:\\n        return 'No transactions found for order ID: {}'.format(order_id)\\n    order_transactions = order_transactions.merge(customer_df, on='user_id', how='left')\\n    order_transactions = order_transactions.merge(product_df, on='item_id', how='left')\\n    product_category_counts = order_transactions['product_category'].value_counts()\\n    if product_category_counts.empty:\\n        return 'No product categories found for order ID: {}'.format(order_id)\\n    top_product_category = product_category_counts.idxmax()\\n    complementary_products = product_df[product_df['product_category'] == top_product_category]['item_id']\\n    purchased_items = order_transactions['item_id']\\n    complementary_products = complementary_products[~complementary_products.isin(purchased_items)]\\n    top_complementary_products = complementary_products.head(top_n).tolist()\\n    return top_complementary_products\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\n\r\nTo find the top-rated transactions within a specific city, you can follow these steps:\r\nJoin the transaction data with the customer data to get the city information.\r\nFilter the transactions based on the specified city.\r\nSort the transactions based on their scores to find the top-rated ones.\n"},{"role":"user","content":"What are the top-rated transactions in City_X for our customers?"},{"role":"assistant","content":"def top_rated_transactions_in_city(df, customer_df, city='City_X'):\\n    merged_df = pd.merge(df, customer_df, on='user_id', how='inner')\\n    city_transactions = merged_df[merged_df['customer_city'] == city]\\n    top_rated_transactions = city_transactions.sort_values(by='score', ascending=False)\\n    return top_rated_transactions\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\n"},{"role":"user","content":"Are there any customers who consistently purchase high-scoring products, and do they tend to reside in specific cities?"},{"role":"assistant","content":"def high_scoring_customers_by_city(df, customer_df):\\n    avg_scores = df.groupby('user_id')['score'].mean()\\n    merged_df = pd.merge(avg_scores, customer_df, on='user_id')\\n    city_avg_scores = merged_df.groupby('customer_city')['score'].mean()\\n    return city_avg_scores\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"Can you suggest additional products for customers who have purchased ITEM_X, based on their transaction history and preferences?"},{"role":"assistant","content":"def suggest_additional_products(df, customer_df, product_df, item_id='ITEM_X', top_n=5):\\n    item_transactions = df[df['item_id'] == item_id]\\n    if item_transactions.empty:\\n        return []  \\n    item_transactions = item_transactions.merge(customer_df, on='user_id', how='left')\\n    item_transactions = item_transactions.merge(product_df, on='item_id', how='left')\\n    category_counts = item_transactions.groupby('product_category').size().reset_index(name='count')\\n    category_counts = category_counts.sort_values(by='count', ascending=False)\\n    category_counts = category_counts[category_counts['product_category'] != item_transactions.iloc[0]['product_category']]\\n    top_categories = category_counts.head(top_n)['product_category']\\n    return top_categories.tolist()\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What is the average transaction score for each product category?"},{"role":"assistant","content":"def customer_segmentation(df, customer_df, product_df, segmentation_strategy='product_category'):\\n    \"\"\"\\n    Perform customer segmentation based on the given strategy.\\n    Parameters:\\n    df (DataFrame): Transaction data.\\n    customer_df (DataFrame): Customer data.\\n    product_df (DataFrame): Product data.\\n    segmentation_strategy (str): Strategy for segmentation.\\n                                Options: 'demographics', 'product_category', 'transaction_behavior'\\n    Returns:\\n    DataFrame: Segmented customer groups with relevant information.\\n    \"\"\"\\n    merged_df = pd.merge(df, customer_df, on='user_id')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id')\\n    if segmentation_strategy == 'demographics':\\n        result = merged_df.groupby('customer_city').agg({'score': 'mean'}).reset_index()\\n        result.rename(columns={'score': 'average_transaction_score'}, inplace=True)\\n    elif segmentation_strategy == 'product_category':\\n        result = merged_df.groupby('product_category').agg({'score': 'mean'}).reset_index()\\n        result.rename(columns={'score': 'average_transaction_score'}, inplace=True)\\n    elif segmentation_strategy == 'transaction_behavior':\\n        result = merged_df.groupby('user_id').agg({'order_id': 'count', 'score': 'mean'}).reset_index()\\n        result.rename(columns={'order_id': 'total_transactions', 'score': 'average_transaction_score'}, inplace=True)\\n    return result\\n"}]},{"messages":[{"role":"system","content":"\nYou are a Python function generator. Users will ask you questions in English, \nand you will produce a Python function as answer to the question based on the provided CONTEXT.\n\nCONTEXT:\nPandas DataFrame df containing transaction data with columns order_id, user_id, item_id, timestamp, score.\r\norder_id takes string datatype and identifies the order.\r\nuser_id takes string datatype and identifies the customer.\r\nitem_id takes string datatype that identifies the product.\r\ntimestamp takes timestamp datatype and represents the datetimestamp of transaction.\r\nscore takes float datatype and represents the score of the transaction.\r\nNote that a customer can make multiple transactions for a product but the customer product pair will be just one entry for each order.\r\nPandas DataFrame customer_dfcontaining customer data with columns user_id, customer_city.\r\nuser_id takes string datatype and identifies the customer.\r\ncustomer_city takes string datatype and represents the city where the customer resides.\r\nNote that df can be joined with customer_df on user_id.\r\nPandas DataFrame product_dfcontaining product data with columns item_id, product_category.\r\nitem_id takes string datatype that identifies the product.\r\nproduct_category takes string datatype and represents the product category in the product hierarchy.\r\nNote that df can be joined with product_df on item_id.\n"},{"role":"user","content":"What are the top 5 product recommendations for user 'WWM' based on their past transactions, considering they haven't purchased these products before?"},{"role":"assistant","content":"def next_best_offer_recommendations(df, customer_df, product_df, user_id='WWM', n=5):\\n    merged_df = pd.merge(df, customer_df, on='user_id', how='left')\\n    merged_df = pd.merge(merged_df, product_df, on='item_id', how='left')\\n    user_transactions = merged_df[merged_df['user_id'] == user_id]\\n    category_scores = user_transactions.groupby('product_category')['score'].mean().reset_index()\\n    category_scores = category_scores.sort_values(by='score', ascending=False)\\n    top_categories = category_scores.head(n)['product_category']\\n    recommended_products = []\\n    for category in top_categories:\\n        products_in_category = merged_df[(merged_df['product_category'] == category) & \\n                                         (~merged_df['item_id'].isin(user_transactions['item_id']))]\\n        if not products_in_category.empty:\\n            recommended_products.append(products_in_category.iloc[0])\\n    return recommended_products\\n"}]}]